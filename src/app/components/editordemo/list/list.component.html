<div class="container">
  <div class="row">
    <div class="col-12">
      <div class="alert alert-info">
        The demo is showing the common parts of the grid. The action buttons lead to the editor controls.
      </div>
    </div>
  </div>
  <app-minitabs #tabs></app-minitabs>
  <div class="row" *ngIf="tabs.tabSelected == 'info'">
    <div class="col-12">
      <div class="card card-block clearfix">
        <div class="card-header card-info">
          Common Features of Grid Component
        </div>
        <div class="card-body">
          <p>
            The Grid implementation consists of three parts:
          </p>
          <ol>
            <li>The DataGridComponent itself (using a table and Bootstrap's design)</li>
            <li>The DataGridPagination component (also based on Bootstrap)</li>
            <li>The DataGridModel class, which controls the other two components</li>
          </ol>
          The DataGridModel class has several functions, through that the behavior of the component can be managed:
          <ul>
            <li>Paging (a paging widget for button creation is included)</li>
            <li>Sorting</li>
            <li>Filtering</li>
            <li>Adding / Removing columns</li>
          </ul>
          <h4>Paging (a paging widget for button creation is included)</h4>
          <p>
            Paging is done on the model class. One can implement a custom UI and send the data to the model. Or one can use the
            DataGridPaginationComponent to create a decent pagination in no time. The pagination component supports:
          </p>
          <ul>
            <li>Showing a limited number of pages</li>
            <li>Showing a first page and last page icon</li>
            <li>Showing a next and previous icon</li>
          </ul>
          <h4>Sorting</h4>
          <p>
            Each field can be sorted ascending and descending. Currently, this is a simple array sort using string comparision.
          </p>
          <h4>Filtering</h4>
          <p>For filtering the property <code>filter</code> exists. This property gets a dictionary:</p>
          <pre>{{ '{' }} [prop: string]: any }</pre>
          <p>
            For each property one provides a value, which is used as search pattern using the <code>RegExp</code> class. For ordinary string search
            this works without any additional characters. One can search for multiple properties at the same time. The conjunction is 'OR', that
            means, that the first positive hit returns and the element is declared as "found".
          </p>
          <h4>Adding / Removing columns</h4>
          <p>
            Columns can be added and removed ba manipulating the header data &ndash; meaning that if the header is being removed, the whole column
            disappears. This has no impact on the data, it's a pure UI thing.
          </p>
          <h4>Editor Functions</h4>
          <p>
            The editor functions are not part of the grid, but independent components. They are, however, using the same decorators so they can be
            controlled by the same view model strategy.
          </p>
          <p>
            The actions 'Edit (Field)' in demo leads to an editor generated by the &lt;ac-editor&gt; control, field by field. The actions 'Edit
            (Auto)' leads to an editor generated by the &lt;ac-autoform&gt; control that creates the whole form automatically using the view model's
            decorators.
          </p>
        </div>
      </div>
    </div>
  </div>
  <div class="row" *ngIf="tabs.tabSelected == 'demo'">
    <div class="col-12">
      <form role="search" class="form-inline">
        <fieldset>
          <legend>Integrated Search</legend>
          <div class="input-group" *ngIf="users">
            <div class="input-group-prepend">
              <span class="input-group-text">Search </span>
            </div>
            <div class="input-group-prepend" [ngClass]="{ show: btnToggle }">
              <button class="btn btn-outline-secondary dropdown-toggle" type="button" (click)="btnToggle = !btnToggle">
                a field
              </button>
              <div class="dropdown-menu" [ngClass]="{ show: btnToggle }">
                <a class="dropdown-item" href="#" [routerLink]="" (click)="searchProp = 'email'; btnToggle = false">E-Mail</a>
                <a class="dropdown-item" href="#" [routerLink]="" (click)="searchProp = 'userName'; btnToggle = false">User Name</a>
                <a class="dropdown-item" href="#" [routerLink]="" (click)="searchProp = 'phoneNumber'; btnToggle = false">Phone Number</a>
              </div>
            </div>
            <input type="text" id="searchUsers" class="form-control" title="Search" name="searchItem" [(ngModel)]="searchItem" />
            <div class="input-group-append">
              <span class="input-group-text"><i class="fa fa-search"></i></span>
            </div>
          </div>
          <span class="text text-info" [hidden]="!searchProp">
            You are searching for <b>{{ searchItem }}</b> in property <i>{{ searchProp }}</i
            >.
          </span>
        </fieldset>
      </form>
    </div>
    <div class="col-12">
      <ac-datagrid
        [model]="users"
        [filter]="filter"
        [showEditButton]="true"
        [showDeleteButton]="true"
        textEditButton="Edit"
        textDeleteButton="Delete"
        textButtonsHeader="Actions"
        (onEdit)="editUser($event)"
        (onDelete)="removeUser($event)"
      ></ac-datagrid>
    </div>
    <div class="col-12">
      <form role="search" class="form-inline" *ngIf="users">
        <fieldset>
          <legend>Integrated Pagination Control</legend>
          <div class="row">
            <div class="col-5">
              <div class="input-group" *ngIf="users">
                <div class="input-group-prepend">
                  <span class="input-group-text">Items per page </span>
                </div>
                <select class="form-control" name="pageSize" [(ngModel)]="users.pageSize" name="itemsPerPage">
                  <option [ngValue]="2">2</option>
                  <option [ngValue]="5">5</option>
                  <option [ngValue]="10">10</option>
                </select>
              </div>
            </div>
            <div class="col"></div>
            <div class="col-5">
              <ac-datagrid-pagination *ngIf="users" [maxPageIndex]="users.maxPageIndex" (pageNumberChanged)="users.currentPageIndex = $event">
              </ac-datagrid-pagination>
            </div>
          </div>
        </fieldset>
      </form>
    </div>
  </div>
  <div class="row" *ngIf="tabs.tabSelected == 'code'">
    <div class="col-12">
      <div class="card card-block clearfix">
        <div class="card-header card-success">
          Techniques used
        </div>
        <div class="card-body">
          <p>
            The table is plain HTML. The tricky part is the datamodel, that holds an array of view models. This model class is able to sort, filter,
            page, and so on.
          </p>
          <code>
            <pre>
ngOnInit() {{ '{' }}
  // Here we load some data from a service
  <span style="color: blue">this</span>.apiService.getUsers().subscribe(data => {{ '{' }}
  <span style="color: blue">this</span>.renderData(data);
  });
}

<span style="color: blue">private</span> renderData(data: Array&lt;UserViewModel>) {{ '{' }}
  <span style="color: green">// We use a regular array here, but grid expects GridData for proper rendering.</span>
  <span style="color: green">// The generic is just to help IntelliSense.</span>
  <span style="color: green">// The second parameter provides the class with the decorator's metadata to control the grid.</span>
  <span style="color: blue">this</span>.users = <span style="color: blue">new</span> AcDataGridModel&lt;UserViewModel>(data, UserViewModel);
}</pre>
          </code>
          <p>Now, in <code>this.users</code> of type <code>AcDataGridModel</code> is the model we can use to create a grid.</p>
        </div>
      </div>
    </div>
  </div>
</div>
