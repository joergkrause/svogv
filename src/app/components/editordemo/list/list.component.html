<div class="container">
  <div class="row">
    <div class="col-12">
      <div class="alert alert-info">
        <p>
          The Grid implementation is just a base class that handles the working stuff of the grid within a single class. The demo contains one
          possible UI, actually just a table. You can use any UI you like, based on &lt;table&gt;, &lt;div&gt;, or even &lt;ul&gt;. The basic features
          currently supported are:
        </p>
        <ul>
          <li>Paging (a paging widget for button creation is included)</li>
          <li>Sorting</li>
          <li>Filtering</li>
          <li>Removing columns</li>
        </ul>
        <p>
          The actions 'Edit (Field)' leads to an editor generated by the &lt;ac-editor&gt; control, field by field. The actions 'Edit (Auto)' leads to
          an editor generated by the &lt;ac-autoform&gt; control that creates the whole form automatically using the view model's decorators.
        </p>
      </div>
    </div>
  </div>
  <div class="row">
    <div class="col-12">
      <form role="search" class="form-inline col-md-6">
        <div class="input-group" *ngIf="model">
          <label for="searchUsers">Search </label>
          <input type="text" id="searchUsers" class="form-control" title="Search" name="searchItem" ngModel #searchItem />
          <span class="input-group-addon">
            <i class="fa fa-search"></i>
          </span>
        </div>
      </form>
    </div>
  </div>
  <div class="row">
    <div class="col-12">
      <ac-datagrid
        [model]="users"
        [filter]="searchItem && searchItem.value"
        [showEditButton]="true"
        [showDeleteButton]="true"
        textEditButton="Edit"
        textDeleteButton="Delete"
        textButtonsHeader="Actions"
        (onEdit)="editUser($event)"
        (onDelete)="deleteUser($event)"
      ></ac-datagrid>
      <div class="clearfix">
        <form class="form-inline">
          <div class="form-group" *ngIf="users">
            <label for="pageSize">Items per Page</label>
            <select class="form-control" name="pageSize" [(ngModel)]="users.pageSize" name="itemsPerPage">
              <option [ngValue]="2">2</option>
              <option [ngValue]="5">5</option>
              <option [ngValue]="10">10</option>
            </select>
          </div>
          <div class="pull-right">
            <ac-datagrid-pagination *ngIf="users" [maxPageIndex]="users.maxPageIndex" (pageNumberChanged)="users.currentPageIndex = $event">
            </ac-datagrid-pagination>
          </div>
        </form>
      </div>
    </div>
  </div>
  <div class="row">
    <div class="col-12">
      <div class="card card-block clearfix">
        <div class="card-header card-success">
          Techniques used
        </div>
        <div class="card-body">
          <p>
            The table is plain HTML. The tricky part is the datamodel, that holds an array of view models.
            This model class is able to sort, filter, page, and so on.
          </p>
          <code>
            <pre>
ngOnInit() {{ '{' }}
  // Here we load some data from a service
  <span style="color: blue">this</span>.apiService.getUsers().subscribe(data => {{ '{' }}
  <span style="color: blue">this</span>.renderData(data);
  });
}

<span style="color: blue">private</span> renderData(data: Array&lt;UserViewModel>) {{ '{' }}
  <span style="color: green">// We use a regular array here, but grid expects GridData for proper rendering.</span>
  <span style="color: green">// The generic is just to help IntelliSense.</span>
  <span style="color: green">// The second parameter provides the class with the decorator's metadata to control the grid.</span>
  <span style="color: blue">this</span>.users = <span style="color: blue">new</span> AcDataGridModel&lt;UserViewModel>(data, UserViewModel);
}</pre>
          </code>
          <p>Now, in <code>this.users</code> of type <code>AcDataGridModel</code> is the model we can use to create a grid.</p>
        </div>
      </div>
    </div>
  </div>
</div>
